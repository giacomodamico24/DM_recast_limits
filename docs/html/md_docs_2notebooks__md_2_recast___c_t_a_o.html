<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DM recast limits: Recasting CTAO Projected Upper Limits Notebook</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DM recast limits
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_docs_2notebooks__md_2_recast___c_t_a_o.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Recasting CTAO Projected Upper Limits Notebook </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md16"></a></p>
<p>This notebook reproduces the <b>recasting</b> of published CTAO projected upper limits (ULs) on dark-matter (DM) annihilation channels.</p>
<p>In particular we will use as an example, the ULs of the following CTAO publication</p>
<p>Acharyya, Atreya, et al. "Sensitivity of the Cherenkov Telescope Array to a dark matter signal from the Galactic centre." Journal of cosmology and astroparticle physics 2021.01 (2021): 057.</p>
<p><a href="https://arxiv.org/pdf/2007.16129">https://arxiv.org/pdf/2007.16129</a> Figure 5</p>
<blockquote class="doxtable">
<p>Tip: Run the notebook top-to-bottom from a fresh kernel to ensure reproducibility. </p>
</blockquote>
<h1 class="doxsection"><a class="anchor" id="autotoc_md17"></a>
Imports &amp; Setup <a class="anchor" id="Imports-Setup"></a></h1>
<div class="fragment"><div class="line"><span class="comment"># --- Imports &amp; Setup: see preceding markdown for context ---</span></div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> astropy.units <span class="keyword">as</span> u</div>
<div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"><span class="keyword">import</span> matplotlib.image <span class="keyword">as</span> mpimg</div>
<div class="line"><span class="keyword">from</span> astropy.table <span class="keyword">import</span> Table</div>
<div class="line"><span class="keyword">from</span> scipy  <span class="keyword">import</span> optimize</div>
<div class="line"><span class="keyword">from</span> scipy  <span class="keyword">import</span> integrate</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
Gammapy PrimaryFlux</h1>
<p>gammapy version 1.2</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> gammapy.astro.darkmatter <span class="keyword">import</span>  PrimaryFlux</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md19"></a>
Recast Class <a class="anchor" id="Helper-Functions"></a></h1>
<div class="fragment"><div class="line"><span class="keyword">class </span>Recast_ULs:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Recast published upper limits (ULs) from one DM annihilation channel/model to another,</span></div>
<div class="line"><span class="stringliteral">    using the approximate IRF-free procedure based on photon yields integrated per energy bin.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    This class estimates the (unknown) per-bin coefficients proportional to A_eff / sqrt(b)</span></div>
<div class="line"><span class="stringliteral">    — encoded here as a relative vector V — by *fitting* them with two benchmark channels.</span></div>
<div class="line"><span class="stringliteral">    Once those coefficients are inferred, it applies the ratio formula to</span></div>
<div class="line"><span class="stringliteral">    recast the ULs from a reference channel to a target channel.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="stringliteral">    DM_masses : astropy.units.Quantity</span></div>
<div class="line"><span class="stringliteral">        Array of DM masses (bin centers), with units convertible to GeV.</span></div>
<div class="line"><span class="stringliteral">        Assumed sorted ascending and *defining* the reconstructed-energy binning used in the ULs.</span></div>
<div class="line"><span class="stringliteral">    UL_values : np.ndarray</span></div>
<div class="line"><span class="stringliteral">        Published upper limits (ULs) for the reference channel/model M0, one value per mass bin.</span></div>
<div class="line"><span class="stringliteral">        Shape: (n_bins,).</span></div>
<div class="line"><span class="stringliteral">    spectral_model_in : list</span></div>
<div class="line"><span class="stringliteral">        List of spectral models (callables with `.evaluate(energy)`) for the **reference** channel M0,</span></div>
<div class="line"><span class="stringliteral">        one per mass bin. Each returns dN/dE with units 1/GeV when evaluated on energies.</span></div>
<div class="line"><span class="stringliteral">    spectral_model_out : list</span></div>
<div class="line"><span class="stringliteral">        List of spectral models (same interface) for the **target** channel M1,</span></div>
<div class="line"><span class="stringliteral">        one per mass bin, producing dN/dE for that bin&#39;s DM mass hypothesis.</span></div>
<div class="line"><span class="stringliteral">    spectral_model_in2 : list</span></div>
<div class="line"><span class="stringliteral">        List of spectral models for the **second benchmark** channel M2</span></div>
<div class="line"><span class="stringliteral">        (used only to *fit* the V coefficients against UL_values_2).</span></div>
<div class="line"><span class="stringliteral">    UL_values_2 : np.ndarray</span></div>
<div class="line"><span class="stringliteral">        Published ULs for the second benchmark channel M2, one per mass bin.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="stringliteral">    -----</span></div>
<div class="line"><span class="stringliteral">    - This implementation follows the approximate recasting in which the instrument</span></div>
<div class="line"><span class="stringliteral">      information (A_eff, energy-dispersion, bkg) enters *only* through a per-bin factor</span></div>
<div class="line"><span class="stringliteral">      proportional to A_eff / sqrt(b). The relative vector V is fitted using the</span></div>
<div class="line"><span class="stringliteral">      ratio of ULs between two channels (M0 and M2), then reused to recast M0 -&gt; M1.</span></div>
<div class="line"><span class="stringliteral">    - The energy binning is inferred from the provided DM_masses by constructing borders</span></div>
<div class="line"><span class="stringliteral">      in log-space and using geometric means as bin centers.</span></div>
<div class="line"><span class="stringliteral">    - Each spectral model is evaluated on a fine grid inside each bin and integrated</span></div>
<div class="line"><span class="stringliteral">      with Simpson&#39;s rule to obtain ΔN_gamma per bin.</span></div>
<div class="line"><span class="stringliteral">    - All energies are handled in GeV; dN/dE is converted to 1/GeV before integration.</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__init__(self,</div>
<div class="line">                 DM_masses,</div>
<div class="line">                 UL_values,</div>
<div class="line">                 spectral_model_in,</div>
<div class="line">                 spectral_model_out,</div>
<div class="line">                 spectral_model_in2,</div>
<div class="line">                 UL_values_2):</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># --- Units and inputs</span></div>
<div class="line">        self.energy_unit = u.GeV</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Convert masses to GeV (float array)</span></div>
<div class="line">        self.DM_masses          = DM_masses.to(self.energy_unit).value</div>
<div class="line">        self.UL_values          = np.asarray(UL_values)</div>
<div class="line">        self.spectral_model_in  = spectral_model_in     <span class="comment"># reference channel (M0)</span></div>
<div class="line">        self.spectral_model_out = spectral_model_out    <span class="comment"># target channel    (M1)</span></div>
<div class="line">        self.UL_values_2        = np.asarray(UL_values_2)</div>
<div class="line">        self.spectral_model_in2 = spectral_model_in2    <span class="comment"># second benchmark  (M2)</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># --- Build energy bin borders/centers from mass grid (log-uniform assumption)</span></div>
<div class="line">        <span class="comment"># Infer a &quot;left border&quot; by extrapolating the first log-step backward</span></div>
<div class="line">        logm      = np.log10(self.DM_masses)</div>
<div class="line">        self.emin = 10**(logm[0] - np.diff(logm)[0])</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Borders: [emin, m0, m1, ..., m_{n-1}]</span></div>
<div class="line">        self.energy_borders = np.concatenate(([self.emin], self.DM_masses))</div>
<div class="line">        <span class="comment"># Centers as geometric mean of adjacent borders</span></div>
<div class="line">        self.energy_centers = np.sqrt(self.energy_borders[1:] * self.energy_borders[:-1])</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># --- Precompute ΔN_gamma for each bin and for each model list</span></div>
<div class="line">        <span class="comment"># The matrices store, for each mass bin i, the integral of dN/dE over all bins j</span></div>
<div class="line">        <span class="comment"># (diagonal dominates if spill-over is negligible). Here we assume per-row = per-mass.</span></div>
<div class="line">        n = len(self.energy_centers)</div>
<div class="line">        self.Ngamma_in   = np.empty((n, n))  <span class="comment"># for M0 (reference)</span></div>
<div class="line">        self.Ngamma_out  = np.empty((n, n))  <span class="comment"># for M1 (target)</span></div>
<div class="line">        self.Ngamma_in2  = np.empty((n, n))  <span class="comment"># for M2 (second benchmark)</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Use a fine geometric grid inside each energy bin for robust integration</span></div>
<div class="line">        x_values = np.geomspace(self.energy_borders[:-1], self.energy_borders[1:], 1000)</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(n):</div>
<div class="line">            <span class="comment"># Integrate ΔN_gamma for each row (mass bin i) over all bins j</span></div>
<div class="line">            <span class="comment"># Assumption: spectral_model_*[i] corresponds to DM mass in bin i.</span></div>
<div class="line">            y_values = self.spectral_model_in[i].evaluate(x_values * self.energy_unit).to(1 / self.energy_unit).value</div>
<div class="line">            self.Ngamma_in[i, :] = integrate.simpson(y_values, x=x_values, axis=0)</div>
<div class="line"> </div>
<div class="line">            y_values = self.spectral_model_in2[i].evaluate(x_values * self.energy_unit).to(1 / self.energy_unit).value</div>
<div class="line">            self.Ngamma_in2[i, :] = integrate.simpson(y_values, x=x_values, axis=0)</div>
<div class="line"> </div>
<div class="line">            y_values = self.spectral_model_out[i].evaluate(x_values * self.energy_unit).to(1 / self.energy_unit).value</div>
<div class="line">            self.Ngamma_out[i, :] = integrate.simpson(y_values, x=x_values, axis=0)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Numerical safety: negative integration artifacts are clipped to zero</span></div>
<div class="line">        self.Ngamma_in[self.Ngamma_in &lt; 0]     = 0.0</div>
<div class="line">        self.Ngamma_out[self.Ngamma_out &lt; 0]   = 0.0</div>
<div class="line">        self.Ngamma_in2[self.Ngamma_in2 &lt; 0]   = 0.0</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># --- Fit the relative per-bin coefficients (A_eff / sqrt(b)) up to a global factor</span></div>
<div class="line">        <span class="comment"># We set the first bin coefficient to 1 and fit the remaining n-1 entries ≥ 0.</span></div>
<div class="line">        initial_guess = np.ones(n - 1)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Target = UL(M2)/UL(M0) (per bin), used to find V such that</span></div>
<div class="line">        <span class="comment"># sqrt(sum K0^2 / sum K2^2) matches this ratio in each mass bin.</span></div>
<div class="line">        target = self.UL_values_2 / self.UL_values</div>
<div class="line"> </div>
<div class="line">        self.result = optimize.least_squares(</div>
<div class="line">            self.residuals,</div>
<div class="line">            initial_guess,</div>
<div class="line">            args=(self.Ngamma_in, self.Ngamma_in2, target),</div>
<div class="line">            bounds=(0, np.inf)  <span class="comment"># enforce non-negativity</span></div>
<div class="line">        )</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Full coefficient vector: first entry fixed to 1 by convention (sets overall scale)</span></div>
<div class="line">        self.V = np.concatenate(([1.0], self.result.x))</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># --- Compute the fraction of K&#39;s needed to recast UL(M0) -&gt; UL(M1)</span></div>
<div class="line">        fraction_of_Ks = self.compute_fraction_of_Ks(self.Ngamma_in, self.Ngamma_out, self.V)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Final recasted ULs for the target channel M1</span></div>
<div class="line">        self.recasted_ULs = fraction_of_Ks * self.UL_values</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>compute_fraction_of_Ks(self,</div>
<div class="line">                               Ngamma_in: np.ndarray,</div>
<div class="line">                               Ngamma_out: np.ndarray,</div>
<div class="line">                               V: np.ndarray) -&gt; np.ndarray:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        Compute the per-mass-bin factor:</span></div>
<div class="line"><span class="stringliteral">            sqrt( sum_j (K_in[j]^2) / sum_j (K_out[j]^2) )</span></div>
<div class="line"><span class="stringliteral">        using K ∝ ΔN_gamma * (A_eff / sqrt(b)) per bin.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="stringliteral">        Ngamma_in : np.ndarray</span></div>
<div class="line"><span class="stringliteral">            Matrix of ΔN_gamma for the reference channel M0, shape (n_bins, n_bins).</span></div>
<div class="line"><span class="stringliteral">        Ngamma_out : np.ndarray</span></div>
<div class="line"><span class="stringliteral">            Matrix of ΔN_gamma for the target channel M1, shape (n_bins, n_bins).</span></div>
<div class="line"><span class="stringliteral">        V : np.ndarray</span></div>
<div class="line"><span class="stringliteral">            Vector of per-bin coefficients proportional to A_eff / sqrt(b),</span></div>
<div class="line"><span class="stringliteral">            length n_bins. First element defines the overall scale.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="stringliteral">        -------</span></div>
<div class="line"><span class="stringliteral">        np.ndarray</span></div>
<div class="line"><span class="stringliteral">            Array of multiplicative factors (length n_bins) to recast ULs</span></div>
<div class="line"><span class="stringliteral">            from M0 to M1 for each mass bin.</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># sum_j [ (ΔN_gamma_in[i, j] * V[j])^2 ]</span></div>
<div class="line">        summed_K_in  = np.sum((Ngamma_in  * V[np.newaxis, :])**2, axis=1)</div>
<div class="line">        summed_K_out = np.sum((Ngamma_out * V[np.newaxis, :])**2, axis=1)</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> np.sqrt(summed_K_in / summed_K_out)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>residuals(self,</div>
<div class="line">                  V_reduced: np.ndarray,</div>
<div class="line">                  Ngamma_in: np.ndarray,</div>
<div class="line">                  Ngamma_out: np.ndarray,</div>
<div class="line">                  target: np.ndarray) -&gt; np.ndarray:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        Residuals for the least-squares fit of the V vector (except the first bin).</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        We define V = [1, a_1, ..., a_{n-1}] and solve for a_k &gt;= 0 such that:</span></div>
<div class="line"><span class="stringliteral">            compute_fraction_of_Ks(Ngamma_in, Ngamma_out, V) ≈ target,</span></div>
<div class="line"><span class="stringliteral">        with target = UL(M2)/UL(M0) for each mass bin.</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="stringliteral">        V_reduced : np.ndarray</span></div>
<div class="line"><span class="stringliteral">            Optimization variable for bins [1..n-1]; bin 0 is fixed to 1.</span></div>
<div class="line"><span class="stringliteral">        Ngamma_in : np.ndarray</span></div>
<div class="line"><span class="stringliteral">            ΔN_gamma for M0 (reference), shape (n_bins, n_bins).</span></div>
<div class="line"><span class="stringliteral">        Ngamma_out : np.ndarray</span></div>
<div class="line"><span class="stringliteral">            ΔN_gamma for M2 (second benchmark), shape (n_bins, n_bins) — used for fitting.</span></div>
<div class="line"><span class="stringliteral">        target : np.ndarray</span></div>
<div class="line"><span class="stringliteral">            Ratio UL(M2)/UL(M0) per mass bin (length n_bins).</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="stringliteral">        -------</span></div>
<div class="line"><span class="stringliteral">        np.ndarray</span></div>
<div class="line"><span class="stringliteral">            Residual vector to be minimized (length n_bins).</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Rebuild full vector with the first element fixed to 1 (sets scale)</span></div>
<div class="line">        V = np.concatenate(([1.0], V_reduced))</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Predicted ratio per mass bin for M0 -&gt; M2, to match the published UL ratio</span></div>
<div class="line">        pred = self.compute_fraction_of_Ks(Ngamma_in, Ngamma_out, V)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Residuals = predicted - target (element-wise)</span></div>
<div class="line">        <span class="keywordflow">return</span> pred - target</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
Case we consider:</h1>
<ul>
<li>channel to recast = $W^+ W^-$</li>
<li>benchmark channek = $b \bar{b}$</li>
<li>second benchmark channek = $\tau^+ \tau^-$</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md21"></a>
Load Data</h2>
<div class="fragment"><div class="line"><span class="comment"># --- Load published CTAO ULs for the reference channel (bb) and</span></div>
<div class="line"><span class="comment">#     interpolate them to a common DM mass grid --------------------</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Read ECSV table with columns: [mass, UL] for Coma Berenices (bb channel)</span></div>
<div class="line">t = Table.read(<span class="stringliteral">&#39;Limits/cta_2021_gc_ann_bb_sens.ecsv&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Extract the DM mass column (astropy Quantity) and sort it ascending (safety)</span></div>
<div class="line">mDM     = t[t.colnames[0]]</div>
<div class="line">argsort = np.argsort(mDM)</div>
<div class="line">mDM     = mDM[argsort]</div>
<div class="line">mDM     = np.array(mDM) * mDM.unit  <span class="comment"># ensure it&#39;s a Quantity array with units</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Extract the corresponding UL values (sigma_v upper limits), and sort consistently</span></div>
<div class="line">sigma   = np.array(t[t.colnames[1]])</div>
<div class="line">sigma   = sigma[argsort]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define a **common mass grid** (log-spaced) to which all channels will be interpolated</span></div>
<div class="line"><span class="comment"># Here: from 50 GeV up to the max mass of the bb table, using 12 points</span></div>
<div class="line">DM_masses = np.geomspace(50 * u.GeV, mDM[-1], 12)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Interpolate the bb ULs to the common mass grid (work in pure floats, keep units separate)</span></div>
<div class="line">sigma_in = np.interp(</div>
<div class="line">    DM_masses.to(u.GeV).value,  <span class="comment"># x: target grid (GeV)</span></div>
<div class="line">    mDM.to(u.GeV).value,        <span class="comment"># xp: original grid (GeV)</span></div>
<div class="line">    sigma                        <span class="comment"># fp: UL values at xp</span></div>
<div class="line">)</div>
<div class="line"><span class="comment"># NOTE: np.interp assumes xp is increasing (we sorted above). It performs linear interpolation</span></div>
<div class="line"><span class="comment"># in linear space. </span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Load second benchmark channel (tau tau) and interpolate to the same grid --------------</span></div>
<div class="line"> </div>
<div class="line">t = Table.read(<span class="stringliteral">&#39;Limits/cta_2021_gc_ann_tautau_sens.ecsv&#39;</span>)</div>
<div class="line"> </div>
<div class="line">mDM     = t[t.colnames[0]]</div>
<div class="line">argsort = np.argsort(mDM)</div>
<div class="line">mDM     = mDM[argsort]</div>
<div class="line"> </div>
<div class="line">sigma   = np.array(t[t.colnames[1]])</div>
<div class="line">sigma   = sigma[argsort]</div>
<div class="line"> </div>
<div class="line">sigma_in2 = np.interp(</div>
<div class="line">    DM_masses.to(u.GeV).value,</div>
<div class="line">    mDM.to(u.GeV).value,</div>
<div class="line">    sigma</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Load the target channel (WW) and interpolate to the same grid ------------------------</span></div>
<div class="line"> </div>
<div class="line">t = Table.read(<span class="stringliteral">&#39;Limits/cta_2021_gc_ann_WW_sens.ecsv&#39;</span>)</div>
<div class="line"> </div>
<div class="line">mDM     = t[t.colnames[0]]</div>
<div class="line">argsort = np.argsort(mDM)</div>
<div class="line">mDM     = mDM[argsort]</div>
<div class="line"> </div>
<div class="line">sigma   = np.array(t[t.colnames[1]])</div>
<div class="line">sigma   = sigma[argsort]</div>
<div class="line"> </div>
<div class="line">sigma_out = np.interp(</div>
<div class="line">    DM_masses.to(u.GeV).value,</div>
<div class="line">    mDM.to(u.GeV).value,</div>
<div class="line">    sigma</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># At this point:</span></div>
<div class="line"><span class="comment"># - DM_masses (Quantity) is the unified mass grid</span></div>
<div class="line"><span class="comment"># - sigma_in  contains ULs for bb on that grid</span></div>
<div class="line"><span class="comment"># - sigma_in2 contains ULs for tau tau on that grid (used to fit A_over_b)</span></div>
<div class="line"><span class="comment"># - sigma_out contains ULs for WW on that grid (used as target comparison)</span></div>
<div class="line"><span class="comment">#</span></div>
<div class="line"><span class="comment"># These three arrays can be passed to Recast_ULs along with the spectral models to</span></div>
<div class="line"><span class="comment"># fit the per-bin coefficients and compute the recasted ULs.</span></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
Recasting Computation <a class="anchor" id="Recasting-Computation"></a></h2>
<div class="fragment"><div class="line"><span class="comment"># --- Recasting Computation: bb → W using tau as secondary benchmark -----------------------</span></div>
<div class="line"><span class="comment"># Goal:</span></div>
<div class="line"><span class="comment">#   Recast published ULs from the bb channel (sigma_in) into ULs for the W channel,</span></div>
<div class="line"><span class="comment">#   using the tau channel (sigma_in2) to infer the per-bin coefficients A_eff/sqrt(b)</span></div>
<div class="line"><span class="comment">#   in the IRF-free approximation.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Choose the *target* channel to recast to (CTAO nomenclature: &#39;W&#39; ≡ W+W-)</span></div>
<div class="line">channel_to_recast = <span class="stringliteral">&#39;W&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Build per-mass spectral models dN/dE for:</span></div>
<div class="line"><span class="comment">#   - sp_in:   reference channel (bb), provides the &quot;source&quot; ULs to be recast</span></div>
<div class="line"><span class="comment">#   - sp_out:  target channel (W+W-), where we want the recasted ULs</span></div>
<div class="line"><span class="comment">#   - sp_in_2: second benchmark channel (tau), used ONLY to fit A_over_b coefficients</span></div>
<div class="line">sp_out  = [PrimaryFlux(mDM=im, channel=channel_to_recast) <span class="keywordflow">for</span> im <span class="keywordflow">in</span> DM_masses]</div>
<div class="line">sp_in   = [PrimaryFlux(mDM=im, channel=<span class="stringliteral">&#39;b&#39;</span>)              <span class="keywordflow">for</span> im <span class="keywordflow">in</span> DM_masses]</div>
<div class="line">sp_in_2 = [PrimaryFlux(mDM=im, channel=<span class="stringliteral">&#39;tau&#39;</span>)            <span class="keywordflow">for</span> im <span class="keywordflow">in</span> DM_masses]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Instantiate the recaster:</span></div>
<div class="line"><span class="comment"># Inputs:</span></div>
<div class="line"><span class="comment">#   - DM_masses:     common mass grid (Quantity, GeV)</span></div>
<div class="line"><span class="comment">#   - spectral_model_in:   models for reference channel (bb)</span></div>
<div class="line"><span class="comment">#   - spectral_model_out:  models for target channel   (W)</span></div>
<div class="line"><span class="comment">#   - UL_values:           published ULs for reference channel (bb) on the common grid</span></div>
<div class="line"><span class="comment">#   - UL_values_2:         published ULs for second benchmark (tau) on the same grid</span></div>
<div class="line"><span class="comment">#   - spectral_model_in2:  models for second benchmark (tau)</span></div>
<div class="line"><span class="comment">#</span></div>
<div class="line"><span class="comment"># What happens inside:</span></div>
<div class="line"><span class="comment">#   1) ΔN_gamma are integrated per energy bin for each mass and channel.</span></div>
<div class="line"><span class="comment">#   2) A_over_b (∝ A_eff / sqrt(b)) per-bin coefficients are *fitted* so that</span></div>
<div class="line"><span class="comment">#      the predicted bb→tau ratio reproduces the published UL ratio sigma_in2 / sigma_in.</span></div>
<div class="line"><span class="comment">#   3) Those coefficients are then used to compute the bb→W recasting factor and</span></div>
<div class="line"><span class="comment">#      generate recasted ULs for the W channel.</span></div>
<div class="line">r = Recast_ULs(</div>
<div class="line">    DM_masses=DM_masses,</div>
<div class="line">    spectral_model_in=sp_in,        <span class="comment"># reference (bb)</span></div>
<div class="line">    spectral_model_out=sp_out,      <span class="comment"># target (W)</span></div>
<div class="line">    UL_values=sigma_in,             <span class="comment"># ULs for bb</span></div>
<div class="line">    UL_values_2=sigma_in2,          <span class="comment"># ULs for tau (second benchmark)</span></div>
<div class="line">    spectral_model_in2=sp_in_2      <span class="comment"># spectra for tau</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Results available as:</span></div>
<div class="line"><span class="comment">#   r.recasted_ULs  → recasted ULs for the W channel on DM_masses grid</span></div>
<div class="line"><span class="comment">#   r.A_ober_b      → fitted per-bin coefficients (relative scale of A_eff/sqrt(b))</span></div>
<div class="line"><span class="comment">#   r.result        → least-squares optimization result (diagnostics)</span></div>
</div><!-- fragment --> <pre class="fragment">/var/folders/cc/9yrg3qln5sq119c30p8bh2h00000gn/T/ipykernel_35978/59134382.py:154: RuntimeWarning: divide by zero encountered in divide
  return np.sqrt(summed_K_in / summed_K_out)
</pre><h2 class="doxsection"><a class="anchor" id="autotoc_md23"></a>
Plot recasting</h2>
<div class="fragment"><div class="line"><span class="comment"># --- Plotting &amp; Visualization: overlay recasted ULs on published CTAO figure -------------</span></div>
<div class="line"><span class="comment"># Goal:</span></div>
<div class="line"><span class="comment">#   1) Show our recasted bb → W limits (blue line) on top of the original CTAO plot image.</span></div>
<div class="line"><span class="comment">#   2) Display, in a second (bottom) panel, the relative difference (%) between the</span></div>
<div class="line"><span class="comment">#      recasted limits and the published CTAO W+W− ULs interpolated on our mass grid.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Load the base image (screenshot of the published CTAO figure 5, W channel)</span></div>
<div class="line">image_path = <span class="stringliteral">&#39;./Paper_figures/CTAO_W_GC.png&#39;</span></div>
<div class="line">img = mpimg.imread(image_path)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a 2-row figure: top panel = UL curves on top of background image,</span></div>
<div class="line"><span class="comment"># bottom panel = percent variation (recast vs published)</span></div>
<div class="line">fig, ax = plt.subplots(</div>
<div class="line">    nrows=2, ncols=1, dpi=500, figsize=(8, 6),</div>
<div class="line">    height_ratios=[5, 1], sharex=<span class="keyword">True</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Reduce vertical spacing between the two panels for a tighter look</span></div>
<div class="line">fig.subplots_adjust(hspace=0.05)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- TOP PANEL: recasted ULs overlaid on the published background plot -------------------</span></div>
<div class="line"><span class="comment"># The &#39;extent&#39; maps the image pixel coordinates into data coordinates (log10 mass, log10 UL).</span></div>
<div class="line"><span class="comment"># These values must match the axes ranges used by the original figure to align correctly.</span></div>
<div class="line">ax[0].imshow(</div>
<div class="line">    img,</div>
<div class="line">    extent=[np.log10(95), np.log10(1e5), np.log10(0.9e-27), np.log10(1e-24)],</div>
<div class="line">    aspect=<span class="stringliteral">&#39;auto&#39;</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Apply the same (log10) axis limits as the original plot to ensure perfect overlay</span></div>
<div class="line">ax[0].set_xlim([np.log10(100), np.log10(1e5)])  </div>
<div class="line">ax[0].set_ylim([np.log10(1e-27), np.log10(1e-24)])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Plot the recasted limits (bb → W) as a thick blue line on the log10 axes</span></div>
<div class="line">ax[0].plot(</div>
<div class="line">    np.log10(DM_masses.to(u.GeV).value),</div>
<div class="line">    np.log10(r.recasted_ULs),</div>
<div class="line"> c=<span class="stringliteral">&#39;blue&#39;</span>, alpha =0.55, label=<span class="stringliteral">r&#39;Recast limits&#39;</span>, linewidth=4.1 </div>
<div class="line"> )</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Legend styling: place it on transparent background above the image</span></div>
<div class="line">ax[0].legend(loc=[0.524,0.69], facecolor=<span class="stringliteral">&#39;none&#39;</span>, edgecolor=<span class="stringliteral">&#39;none&#39;</span>,handlelength=2.9)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Axis labels (note: values on axes are log10-scaled, displayed as powers of 10 via tick labels)</span></div>
<div class="line">ax[0].set_ylabel(<span class="stringliteral">r&#39;$ \langle \sigma v \rangle \; [\mathrm{cm}^3\,\mathrm{s}^{-1}] $&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Hide tick marks (keep only tick labels for a clean look over an image)</span></div>
<div class="line">ax[0].tick_params(axis=<span class="stringliteral">&#39;both&#39;</span>, which=<span class="stringliteral">&#39;both&#39;</span>, length=0)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Custom ticks in log10 space for both axes</span></div>
<div class="line">custom_x_ticks = np.log10(np.array([100, 1000, 10000, 100000]) )</div>
<div class="line">ax[0].set_xticks(custom_x_ticks)</div>
<div class="line">ax[0].set_xticklabels([<span class="stringliteral">&#39;$10^2$&#39;</span>, <span class="stringliteral">&#39;$10^3$&#39;</span>, <span class="stringliteral">&#39;$10^4$&#39;</span>, <span class="stringliteral">&#39;$10^5$&#39;</span>])</div>
<div class="line"> </div>
<div class="line">custom_y_ticks = np.log10( [ 1e-27, 1e-26, 1e-25, 1e-24] )</div>
<div class="line">ax[0].set_yticks(custom_y_ticks)</div>
<div class="line">ax[0].set_yticklabels([<span class="stringliteral">&#39;$10^{-27}$&#39;</span> ,<span class="stringliteral">&#39;$10^{-26}$&#39;</span>, <span class="stringliteral">&#39;$10^{-25}$&#39;</span>, <span class="stringliteral">&#39;$10^{-24}$&#39;</span>])</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- BOTTOM PANEL: percent variation between recast and published ULs --------------------</span></div>
<div class="line"><span class="comment"># Compute the relative difference (in %) between our recasted ULs and the published W ULs</span></div>
<div class="line"><span class="comment"># (sigma_out is the CTAO W+W− UL interpolated on our mass grid).</span></div>
<div class="line">yy = (r.recasted_ULs - sigma_out) / sigma_out * 100.0</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">ax[1].plot( np.log10(DM_masses.to(u.GeV).value),</div>
<div class="line">    yy,</div>
<div class="line">    c=<span class="stringliteral">&#39;blue&#39;</span>, alpha=0.55, linewidth=4.1)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># Labels, grid, and sensible y-range for residuals</span></div>
<div class="line">ax[1].set_xlabel(<span class="stringliteral">&#39;DM mass [GeV]&#39;</span>)</div>
<div class="line">ax[1].set_ylabel(<span class="stringliteral">&#39;Variation [%]&#39;</span>, fontsize=8)</div>
<div class="line">ax[1].grid(linewidth=0.3)</div>
<div class="line">ax[1].set_ylim(-40, 40)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Optional: tighten layout to avoid label clipping (especially with high DPI)</span></div>
<div class="line">plt.tight_layout()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Show on screen (or replace with plt.savefig(&#39;out.png&#39;, dpi=500) to save)</span></div>
<div class="line">plt.show()</div>
</div><!-- fragment --> <pre class="fragment">[1.69897    1.99849188 2.29801376 2.59753564 2.89705752 3.1965794
 3.49610128 3.79562316 4.09514504 4.39466692 4.6941888  4.99371068]
</pre><p><img src="Recast_CTAO_files/Recast_CTAO_13_1.png" alt="png" class="inline"/> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
